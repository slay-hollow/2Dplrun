<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ–¹å—æ¶ˆé™¤ - æ¨ç®±å­è§£è°œ</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #263238; /* æ·±ç°è‰²èƒŒæ™¯ */
            color: white;
            flex-direction: column;
            font-family: monospace, sans-serif;
        }
        #game-container {
            border: 3px solid #64b5f6;
            box-shadow: 0 0 10px rgba(100, 181, 246, 0.7);
            position: relative;
        }
        #game-canvas {
            display: block;
            background-color: #455a64; /* æ¸¸æˆåŒºåŸŸèƒŒæ™¯ */
        }
        #info-panel {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }
        #info-panel h1 {
            color: #ffeb3b;
            font-size: 3em;
        }
        .control-button {
            padding: 10px 20px;
            font-size: 1.2em;
            cursor: pointer;
            margin: 10px;
            background-color: #ff9800; /* æ©™è‰²æŒ‰é’® */
            color: white;
            border: none;
            transition: background-color 0.3s;
        }
        .control-button:hover {
            background-color: #f57c00;
        }
        .hud-item {
            margin-top: 10px;
            font-size: 1.2em;
        }
    </style>
</head>
<body>

    <h1>ğŸ§± æ–¹å—æ¶ˆé™¤ - æ¨ç®±å­</h1>

    <div id="game-container">
        <canvas id="game-canvas" width="400" height="400"></canvas>

        <div id="info-panel">
            <h1>æ–¹å—æ¶ˆé™¤</h1>
            <p>æ“ä½œï¼šæ–¹å‘é”®/WASD ç§»åŠ¨ã€‚</p>
            <p>ç›®æ ‡ï¼šå°†æ‰€æœ‰ç®±å­ (ğŸ“¦) æ¨åˆ°ç›®æ ‡ç‚¹ (ğŸ¯) ä¸Šã€‚</p>
            <button id="start-button" class="control-button">å¼€å§‹è§£è°œ</button>
            <p class="hud-item"><a href="index.html" style="color: #64b5f6;">è¿”å›æ¸¸æˆå¤§å…</a></p>
        </div>
    </div>

    <div class="hud-item">
        å…³å¡: <span id="level-display">1 / 2</span> | æ­¥æ•°: <span id="moves-display">0</span> 
        <button id="reset-button" class="control-button" onclick="resetLevel()">é‡ç½®å…³å¡</button>
    </div>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const GAME_SIZE = canvas.width;

        let gameState = 'START';
        const TILE_SIZE = 40;
        const GRID_SIZE = 10; // 10x10 ç½‘æ ¼

        let player = { x: 0, y: 0 };
        let boxes = [];
        let targets = [];
        let mapData = [];
        let currentLevelIndex = 0;
        let moves = 0;

        // --- å…³å¡æ•°æ® ---
        // 0: åœ°æ¿ (Floor)
        // 1: å¢™å£ (Wall)
        // 2: ç›®æ ‡ç‚¹ (Target)
        // 3: ç©å®¶èµ·å§‹ç‚¹ (Player Start)
        // 4: ç®±å­èµ·å§‹ç‚¹ (Box Start)
        // æ³¨æ„ï¼šç©å®¶å’Œç®±å­çš„å®é™…ä½ç½®å­˜å‚¨åœ¨ player å’Œ boxes æ•°ç»„ä¸­
        const levels = [
            // Level 1: ç®€å•æ¨å…¥
            [
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                1, 0, 4, 0, 0, 0, 0, 0, 0, 1,
                1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                1, 0, 3, 0, 0, 0, 0, 2, 2, 1,
                1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1
            ],
            // Level 2: ç¨å¾®å¤æ‚
            [
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
                1, 2, 0, 0, 1, 0, 0, 0, 0, 1,
                1, 0, 4, 0, 1, 0, 4, 0, 0, 1,
                1, 0, 0, 0, 0, 0, 0, 1, 0, 1,
                1, 0, 0, 1, 1, 1, 0, 1, 0, 1,
                1, 0, 0, 0, 0, 1, 0, 1, 0, 1,
                1, 0, 4, 0, 0, 1, 0, 1, 0, 1,
                1, 0, 3, 0, 0, 0, 0, 2, 2, 1,
                1, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                1, 1, 1, 1, 1, 1, 1, 1, 1, 1
            ]
        ];

        // --- åˆå§‹åŒ–å…³å¡ ---
        function loadLevel(index) {
            currentLevelIndex = index;
            mapData = levels[index];
            boxes = [];
            targets = [];
            moves = 0;
            
            for (let i = 0; i < mapData.length; i++) {
                const mapValue = mapData[i];
                const y = Math.floor(i / GRID_SIZE);
                const x = i % GRID_SIZE;

                if (mapValue === 3) {
                    player.x = x;
                    player.y = y;
                } else if (mapValue === 4) {
                    boxes.push({ x: x, y: y });
                } else if (mapValue === 2) {
                    targets.push({ x: x, y: y });
                }
            }
            updateHUD();
        }

        function resetLevel() {
             // é‡æ–°åŠ è½½å½“å‰å…³å¡
             loadLevel(currentLevelIndex);
             gameState = 'PLAYING';
        }


        // -------------------------------------
        // æ¸¸æˆé€»è¾‘ï¼šç§»åŠ¨å’Œæ¨ç®±å­
        // -------------------------------------
        
        // æ£€æŸ¥ç»™å®šåæ ‡ (x, y) æ˜¯å¦æœ‰ç®±å­
        function getBoxIndex(x, y) {
            return boxes.findIndex(box => box.x === x && box.y === y);
        }
        
        // æ£€æŸ¥ç»™å®šåæ ‡ (x, y) æ˜¯å¦æ˜¯å¢™å£
        function isWall(x, y) {
            // è¾¹ç•Œæ£€æŸ¥
            if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return true;
            // åœ°å›¾æ•°æ®æ£€æŸ¥
            const index = y * GRID_SIZE + x;
            return mapData[index] === 1;
        }

        // å¤„ç†ç©å®¶ç§»åŠ¨
        function movePlayer(dx, dy) {
            if (gameState !== 'PLAYING') return;

            const newX = player.x + dx;
            const newY = player.y + dy;

            if (isWall(newX, newY)) {
                return; // æ’å¢™ï¼Œä¸åŠ¨
            }

            const boxIndex = getBoxIndex(newX, newY);
            
            if (boxIndex !== -1) {
                // ç¢°åˆ°ç®±å­ï¼Œå°è¯•æ¨åŠ¨
                const boxNewX = newX + dx;
                const boxNewY = newY + dy;

                if (isWall(boxNewX, boxNewY) || getBoxIndex(boxNewX, boxNewY) !== -1) {
                    return; // æ¨åŠ¨å¤±è´¥ï¼šå‰é¢æ˜¯å¢™æˆ–å¦ä¸€ä¸ªç®±å­
                }

                // æ¨åŠ¨æˆåŠŸ
                boxes[boxIndex].x = boxNewX;
                boxes[boxIndex].y = boxNewY;
            }
            
            // ç§»åŠ¨ç©å®¶
            player.x = newX;
            player.y = newY;
            moves++;
            updateHUD();

            // æ£€æŸ¥èƒœåˆ©æ¡ä»¶
            checkWinCondition();
        }

        // æ£€æŸ¥èƒœåˆ©æ¡ä»¶
        function checkWinCondition() {
            let boxesOnTarget = 0;
            
            if (targets.length === 0) return;

            boxes.forEach(box => {
                const isOnTarget = targets.some(target => target.x === box.x && target.y === box.y);
                if (isOnTarget) {
                    boxesOnTarget++;
                }
            });

            if (boxesOnTarget === targets.length) {
                // èƒœåˆ©ï¼
                gameState = 'WIN';
                setTimeout(showWinScreen, 50); 
            }
        }
        
        // -------------------------------------
        // æ¸²æŸ“å’Œäº‹ä»¶
        // -------------------------------------

        function draw() {
            // æ¸…é™¤ç”»å¸ƒ
            ctx.fillStyle = '#455a64';
            ctx.fillRect(0, 0, GAME_SIZE, GAME_SIZE);
            
            // ç»˜åˆ¶ç½‘æ ¼çº¿
            ctx.strokeStyle = '#37474f';
            for (let i = 0; i <= GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(i * TILE_SIZE, 0);
                ctx.lineTo(i * TILE_SIZE, GAME_SIZE);
                ctx.moveTo(0, i * TILE_SIZE);
                ctx.lineTo(GAME_SIZE, i * TILE_SIZE);
                ctx.stroke();
            }

            // ç»˜åˆ¶åœ°å›¾å…ƒç´  (å¢™å£/ç›®æ ‡ç‚¹)
            for (let i = 0; i < mapData.length; i++) {
                const mapValue = mapData[i];
                const y = Math.floor(i / GRID_SIZE);
                const x = i % GRID_SIZE;

                if (mapValue === 1) { // å¢™å£
                    ctx.fillStyle = '#37474f';
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }

            // ç»˜åˆ¶ç›®æ ‡ç‚¹ (åœ¨å¢™å£ä¹‹ä¸Šï¼Œç®±å­ä¹‹ä¸‹)
            targets.forEach(target => {
                ctx.fillStyle = 'rgba(255, 165, 0, 0.5)'; // é€æ˜æ©™è‰²
                ctx.beginPath();
                ctx.arc(target.x * TILE_SIZE + TILE_SIZE / 2, target.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ffeb3b'; // ç›®æ ‡ç¬¦å· ğŸ¯
                ctx.font = `${TILE_SIZE * 0.7}px monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('ğŸ¯', target.x * TILE_SIZE + TILE_SIZE / 2, target.y * TILE_SIZE + TILE_SIZE / 2);
            });

            // ç»˜åˆ¶ç®±å­
            boxes.forEach(box => {
                let isOnTarget = targets.some(target => target.x === box.x && target.y === box.y);
                
                ctx.fillStyle = isOnTarget ? '#00e676' : '#9e9e9e'; // ç»¿è‰²è¡¨ç¤ºåˆ°ä½
                ctx.fillRect(box.x * TILE_SIZE + 5, box.y * TILE_SIZE + 5, TILE_SIZE - 10, TILE_SIZE - 10);
                
                ctx.fillStyle = '#000'; // ç®±å­ç¬¦å· ğŸ“¦
                ctx.font = `${TILE_SIZE * 0.6}px monospace`;
                ctx.fillText('ğŸ“¦', box.x * TILE_SIZE + TILE_SIZE / 2, box.y * TILE_SIZE + TILE_SIZE / 2);
            });
            
            // ç»˜åˆ¶ç©å®¶
            ctx.fillStyle = '#64b5f6'; // è“è‰²ç©å®¶
            ctx.beginPath();
            ctx.arc(player.x * TILE_SIZE + TILE_SIZE / 2, player.y * TILE_SIZE + TILE_SIZE / 2, TILE_SIZE / 2 - 5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#000'; // ç©å®¶ç¬¦å· ğŸƒ
            ctx.font = `${TILE_SIZE * 0.7}px monospace`;
            ctx.fillText('ğŸƒ', player.x * TILE_SIZE + TILE_SIZE / 2, player.y * TILE_SIZE + TILE_SIZE / 2);
        }

        function updateHUD() {
            document.getElementById('level-display').textContent = (currentLevelIndex + 1) + ' / ' + levels.length;
            document.getElementById('moves-display').textContent = moves;
        }

        function loop() {
            draw();
            requestAnimationFrame(loop);
        }

        // -------------------------------------
        // ç•Œé¢å’Œæµç¨‹æ§åˆ¶
        // -------------------------------------

        function showWinScreen() {
            document.getElementById('info-panel').style.display = 'flex';
            
            let content;
            if (currentLevelIndex < levels.length - 1) {
                // è¿›å…¥ä¸‹ä¸€å…³
                content = `
                    <h1>æ­å–œé€šè¿‡ç¬¬ ${currentLevelIndex + 1} å…³!</h1>
                    <p>æ€»æ­¥æ•°: ${moves}</p>
                    <button id="next-level-button" class="control-button">è¿›å…¥ä¸‹ä¸€å…³</button>
                    <p class="hud-item"><a href="index.html" style="color: #64b5f6;">è¿”å›æ¸¸æˆå¤§å…</a></p>
                `;
            } else {
                // å…¨éƒ¨é€šå…³
                content = `
                    <h1>ğŸ‰ æ­å–œï¼æ‚¨æ˜¯è§£è°œå¤§å¸ˆï¼</h1>
                    <p>æ‰€æœ‰å…³å¡å®Œæˆã€‚</p>
                    <button id="restart-button" class="control-button" onclick="startGame(0)">é‡æ–°å¼€å§‹</button>
                    <p class="hud-item"><a href="index.html" style="color: #64b5f6;">è¿”å›æ¸¸æˆå¤§å…</a></p>
                `;
            }

            document.getElementById('info-panel').innerHTML = content;
            
            if (currentLevelIndex < levels.length - 1) {
                document.getElementById('next-level-button').addEventListener('click', () => startGame(currentLevelIndex + 1));
            }
        }
        
        function startGame(startLevelIndex = 0) {
            document.getElementById('info-panel').style.display = 'none';
            gameState = 'PLAYING';
            loadLevel(startLevelIndex);
        }
        
        // -------------------------------------
        // é”®ç›˜è¾“å…¥æ˜ å°„
        // -------------------------------------

        window.addEventListener('keydown', (e) => {
            if (gameState !== 'PLAYING') return;

            e.preventDefault();
            let dx = 0;
            let dy = 0;

            switch (e.key.toLowerCase()) {
                case 'arrowup':
                case 'w':
                    dy = -1;
                    break;
                case 'arrowdown':
                case 's':
                    dy = 1;
                    break;
                case 'arrowleft':
                case 'a':
                    dx = -1;
                    break;
                case 'arrowright':
                case 'd':
                    dx = 1;
                    break;
                case 'r': // R é”®å¿«é€Ÿé‡ç½®
                    resetLevel();
                    break;
                default:
                    return;
            }

            if (dx !== 0 || dy !== 0) {
                movePlayer(dx, dy);
            }
        });

        // --- åˆå§‹åŒ– ---
        document.getElementById('start-button').addEventListener('click', () => startGame(0));
        loadLevel(0); // é¢„åŠ è½½ç¬¬ä¸€å…³åœ°å›¾
        loop();
    </script>

</body>
</html>
